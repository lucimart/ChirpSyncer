import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { api } from './api';

// Trigger types supported by backend
export type TriggerType =
  | 'new_post'
  | 'viral_post'
  | 'new_mention'
  | 'scheduled'
  | 'webhook'
  | 'rss';

// Action types supported by backend
export type ActionType =
  | 'cross_post'
  | 'send_notification'
  | 'transform_content'
  | 'add_to_queue';

// Platform types for cross-posting
export type Platform = 'twitter' | 'bluesky' | 'both';

// Trigger configurations
export interface NewPostTriggerConfig {
  type: 'new_post';
  platform: Platform;
}

export interface ViralPostTriggerConfig {
  type: 'viral_post';
  platform: Platform;
  threshold: {
    likes?: number;
    retweets?: number;
  };
}

export interface NewMentionTriggerConfig {
  type: 'new_mention';
  platform: Platform;
}

export interface ScheduledTriggerConfig {
  type: 'scheduled';
  cron: string;
}

export interface WebhookTriggerConfig {
  type: 'webhook';
  webhook_url?: string; // Generated by backend
}

export interface RssTriggerConfig {
  type: 'rss';
  feed_url: string;
}

export type TriggerConfig =
  | NewPostTriggerConfig
  | ViralPostTriggerConfig
  | NewMentionTriggerConfig
  | ScheduledTriggerConfig
  | WebhookTriggerConfig
  | RssTriggerConfig;

// Action configurations
export interface CrossPostActionConfig {
  type: 'cross_post';
  platforms: Platform[];
}

export interface SendNotificationActionConfig {
  type: 'send_notification';
  channel: 'email' | 'webhook' | 'push';
  message_template: string;
}

export interface TransformContentActionConfig {
  type: 'transform_content';
  target_platform: Platform;
  truncate?: boolean;
  add_hashtags?: string[];
  remove_hashtags?: boolean;
}

export interface AddToQueueActionConfig {
  type: 'add_to_queue';
  queue_name?: string;
  priority?: 'low' | 'normal' | 'high';
}

export type ActionConfig =
  | CrossPostActionConfig
  | SendNotificationActionConfig
  | TransformContentActionConfig
  | AddToQueueActionConfig;

// Workflow status
export type WorkflowStatus = 'running' | 'completed' | 'failed';

// Main Workflow interface
export interface Workflow {
  id: string;
  name: string;
  description?: string;
  is_active: boolean;
  trigger_config: TriggerConfig;
  actions_config: ActionConfig[];
  run_count: number;
  last_run_at?: string;
  created_at: string;
  updated_at: string;
}

// Workflow run history
export interface WorkflowRun {
  id: string;
  workflow_id: string;
  trigger_data: Record<string, unknown>;
  status: WorkflowStatus;
  actions_completed: string[];
  error_message?: string;
  started_at: string;
  completed_at?: string;
}

// API responses
export interface WorkflowsResponse {
  workflows: Workflow[];
  total: number;
}

export interface WorkflowRunsResponse {
  runs: WorkflowRun[];
  total: number;
}

// Create/Update payload
export interface WorkflowPayload {
  name: string;
  description?: string;
  is_active?: boolean;
  trigger_config: TriggerConfig;
  actions_config: ActionConfig[];
}

// Query keys
export const workflowKeys = {
  all: ['workflows'] as const,
  list: () => [...workflowKeys.all, 'list'] as const,
  detail: (id: string) => [...workflowKeys.all, 'detail', id] as const,
  runs: (id: string) => [...workflowKeys.all, 'runs', id] as const,
};

/**
 * Fetch all workflows
 */
export function useWorkflows() {
  return useQuery<WorkflowsResponse>({
    queryKey: workflowKeys.list(),
    queryFn: async () => {
      const response = await api.get<WorkflowsResponse>('/workflows');

      if (!response.success || !response.data) {
        throw new Error(response.error || 'Failed to fetch workflows');
      }

      return response.data;
    },
    staleTime: 30000,
  });
}

/**
 * Fetch a single workflow by ID
 */
export function useWorkflow(id: string) {
  return useQuery<Workflow>({
    queryKey: workflowKeys.detail(id),
    queryFn: async () => {
      const response = await api.get<Workflow>(`/workflows/${id}`);

      if (!response.success || !response.data) {
        throw new Error(response.error || 'Failed to fetch workflow');
      }

      return response.data;
    },
    enabled: !!id,
    staleTime: 30000,
  });
}

/**
 * Create a new workflow
 */
export function useCreateWorkflow() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (payload: WorkflowPayload) => {
      const response = await api.post<Workflow>('/workflows', payload);

      if (!response.success || !response.data) {
        throw new Error(response.error || 'Failed to create workflow');
      }

      return response.data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: workflowKeys.all });
    },
  });
}

/**
 * Update an existing workflow
 */
export function useUpdateWorkflow() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ id, payload }: { id: string; payload: Partial<WorkflowPayload> }) => {
      const response = await api.put<Workflow>(`/workflows/${id}`, payload);

      if (!response.success || !response.data) {
        throw new Error(response.error || 'Failed to update workflow');
      }

      return response.data;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: workflowKeys.all });
      queryClient.setQueryData(workflowKeys.detail(data.id), data);
    },
  });
}

/**
 * Delete a workflow
 */
export function useDeleteWorkflow() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (id: string) => {
      const response = await api.delete<{ success: boolean }>(`/workflows/${id}`);

      if (!response.success) {
        throw new Error(response.error || 'Failed to delete workflow');
      }

      return { id };
    },
    onSuccess: ({ id }) => {
      queryClient.invalidateQueries({ queryKey: workflowKeys.list() });
      queryClient.removeQueries({ queryKey: workflowKeys.detail(id) });
    },
  });
}

/**
 * Toggle workflow active status
 */
export function useToggleWorkflow() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ id, is_active }: { id: string; is_active: boolean }) => {
      const response = await api.put<Workflow>(`/workflows/${id}`, { is_active });

      if (!response.success || !response.data) {
        throw new Error(response.error || 'Failed to toggle workflow');
      }

      return response.data;
    },
    // Optimistic update
    onMutate: async ({ id, is_active }) => {
      await queryClient.cancelQueries({ queryKey: workflowKeys.all });

      const previousWorkflows = queryClient.getQueryData<WorkflowsResponse>(workflowKeys.list());
      const previousWorkflow = queryClient.getQueryData<Workflow>(workflowKeys.detail(id));

      // Update list
      if (previousWorkflows) {
        queryClient.setQueryData<WorkflowsResponse>(workflowKeys.list(), {
          ...previousWorkflows,
          workflows: previousWorkflows.workflows.map((w) =>
            w.id === id ? { ...w, is_active } : w
          ),
        });
      }

      // Update detail
      if (previousWorkflow) {
        queryClient.setQueryData<Workflow>(workflowKeys.detail(id), {
          ...previousWorkflow,
          is_active,
        });
      }

      return { previousWorkflows, previousWorkflow };
    },
    onError: (_err, { id }, context) => {
      if (context?.previousWorkflows) {
        queryClient.setQueryData(workflowKeys.list(), context.previousWorkflows);
      }
      if (context?.previousWorkflow) {
        queryClient.setQueryData(workflowKeys.detail(id), context.previousWorkflow);
      }
    },
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: workflowKeys.all });
    },
  });
}

/**
 * Fetch workflow run history
 */
export function useWorkflowRuns(id: string, limit = 50) {
  return useQuery<WorkflowRunsResponse>({
    queryKey: workflowKeys.runs(id),
    queryFn: async () => {
      const response = await api.get<WorkflowRunsResponse>(`/workflows/${id}/runs`, {
        params: { limit },
      });

      if (!response.success || !response.data) {
        throw new Error(response.error || 'Failed to fetch workflow runs');
      }

      return response.data;
    },
    enabled: !!id,
    staleTime: 30000,
    refetchInterval: 30000, // Refresh every 30s to show recent runs
  });
}

/**
 * Test a workflow manually
 */
export function useTestWorkflow() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({
      id,
      test_data,
    }: {
      id: string;
      test_data?: Record<string, unknown>;
    }) => {
      const response = await api.post<WorkflowRun>(`/workflows/${id}/test`, { test_data });

      if (!response.success || !response.data) {
        throw new Error(response.error || 'Failed to test workflow');
      }

      return response.data;
    },
    onSuccess: (_, { id }) => {
      // Refresh runs after test
      queryClient.invalidateQueries({ queryKey: workflowKeys.runs(id) });
    },
  });
}

// Helper functions for trigger/action display
export const TRIGGER_LABELS: Record<TriggerType, string> = {
  new_post: 'New Post',
  viral_post: 'Viral Post',
  new_mention: 'New Mention',
  scheduled: 'Scheduled',
  webhook: 'Webhook',
  rss: 'RSS Feed',
};

export const ACTION_LABELS: Record<ActionType, string> = {
  cross_post: 'Cross-Post',
  send_notification: 'Send Notification',
  transform_content: 'Transform Content',
  add_to_queue: 'Add to Queue',
};

export function getTriggerLabel(type: TriggerType): string {
  return TRIGGER_LABELS[type] || type;
}

export function getActionLabel(type: ActionType): string {
  return ACTION_LABELS[type] || type;
}
